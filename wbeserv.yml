    struct addrinfo hints, *res, *p;
    int getaddr = getaddrinfo("127.0.0.1", "http", &hints, &res);
    if (getaddr != 0)
        std::cout << "error" << std::endl;
        
    void *addr;
    struct sockaddr_in* ipv4 = (struct sockaddr_in*)res->ai_addr;
    uint32_t ip = htonl(ipv4->sin_addr.s_addr);
    
    std::cout << inet_addr_pton(ip) << std::endl;


    const char* inet_addr_pton(uint32_t ipv)
{
    char* ip = new char[16];
    std::stringstream ss;
    ss << ((int)(ipv >> 24) & 0XFF) << "." << ((int)(ipv >> 16) & 0XFF) << "." << ((int)(ipv >> 8) & 0XFF) << "." << ((int)(ipv) & 0XFF);
    int i = -1;
    while (++i < ss.str().size())
        ip[i] = ss.str().c_str()[i];
    ip[i] = '\0';
    return (ip);
}


        // try
        // {
        //     srv.up();
        // }
        // catch(std::exception const &e)
        // {
        //     std::cout << e.what() << std::endl;
        // }
        
        // while (1)
        // {
        //     sock_t client = srv.accept();
        //     if (client > 0)
        //     {
        //         Client cl(client);
        //         srv.request(cl);
        //     }
        // }



                   char http[2048];
                            int rd = recv(client->getFd(), http, sizeof(http), 0);
                            http[rd] = '\0';
                            std::cout << http;
                            std::string response = "HTTP/1.1 200 OK\r\n";
                            response += "Date: Mon, 27 Jul 2009 12:28:53 GMT";
                            response += "Server: Apache/2.2.14 (Win32)\r\n";
                            response += "Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT\r\n";
                            response += "Content-Length: 88\r\n";
                            response += "Content-Type: text/html\r\n";
                            response += "Connection: keep-alive\r\n";
                            response += "\r\n";
                            response += "<html><head><link rel='icon' href='data:,'></head><body><h1>Hello, World!</h1></body></html>";
                            int r = send(client->getFd(), response.c_str(), response.size(), 0);
                            std::cout << "r = " << r << std::endl;
                            mgn.rm_r(client->getFd());
                            close(client->getFd());
                            server->removeClient(client->getFd());






while (true) {
        fd_set s_rd, s_wr, s_ex;
        FD_ZERO(&s_rd);
        FD_ZERO(&s_wr);
        FD_ZERO(&s_ex);

        sock_t max_fd = mgn.getmax();

        s_rd = mgn.r_set();
        s_wr = mgn.w_set();
        s_ex = mgn.e_set();

        int i_o = select(max_fd + 1, &s_rd, &s_wr, NULL, NULL);
        if (i_o > 0) {
            for (int i = 0; i < FD_SETSIZE; ++i) {
                if (FD_ISSET(i, &s_rd)) {
                    if (mgn.findServerBySocket(i) != -1) {
                        std::cout << "Handling server socket: " << i << std::endl;
                        HTTPServer* that = mgn.getServerBySocket(i);
                        sock_t cl = that->accept();
                        Client client(cl);
                        that->push(cl, client);
                        mgn.set_r(cl);
                    } else {
                        HTTPServer* server = mgn.getServerByClientSocket(i);
                        Client* client = server->getClient(i);
                        client->appendRequest();
                        mgn.rm_r(client->getFd());
                        mgn.set_w(client->getFd());
                    }
                } else if (FD_ISSET(i, &s_wr)) {
                    if (mgn.findClientBySocket(i) != -1) {
                        std::cout << "Handling client socket: " << i << std::endl;
                        HTTPServer* server = mgn.getServerByClientSocket(i);
                        Client* client = server->getClient(i);

                        std::string response = "HTTP/1.1 200 OK\r\n\r\n";
                        response += file("www/server1/index.html");

                        ssize_t wr = send(client->getFd(), response.c_str(), response.size(), 0);
                        if (wr == -1) {
                            // Handle send error
                        } else {
                            close(client->getFd());
                            mgn.rm_w(client->getFd());
                            server->removeClient(client->getFd());
                            response.clear();
                        }
                    }
                }
            }
        } else if (i_o == -1) {
            // Handle select error
        }
    }












    while (1)
        {
            sock_t found = 0;
            FD_ZERO(&s_rd);
            FD_ZERO(&s_wr);
            FD_ZERO(&s_ex);
            s_rd = mgn.r_set();
            s_wr = mgn.w_set();
            s_ex = mgn.e_set();
            int i_o = select(mgn.getmax()+1, &s_rd, &s_wr, NULL, NULL);
            
            if (i_o > 0)
            {
                for(int i = 0; i < FD_SETSIZE; i++)
                {
                    if (FD_ISSET(i, &s_rd))
                    {
                        if ((found = mgn.findServerBySocket(i)) != -1)
                        {
                            std::cout << "server: " << i << " qtel em" << std::endl;
                            HTTPServer* that = mgn.getServerBySocket(i);
                            sock_t cl = that->accept();
                            Client client(cl);
                            that->push(cl, client);
                            mgn.set_r(cl);
                        }
                        else
                        {                           
                            HTTPServer* server = mgn.getServerByClientSocket(i);
                            Client* client = server->getClient(i);
                            client->appendRequest();
                            mgn.set_w(client->getFd());
                        }
                    }
                    if (FD_ISSET(i, &s_wr)) {
                        if ((found = mgn.findClientBySocket(i)) != -1)
                        {
                            HTTPServer* server = mgn.getServerByClientSocket(i);
                            Client* client = server->getClient(i);

                            
                            std::string response = "HTTP/1.1 200 OK\r\n";
                            response += "\r\n";
                            response += file("www/server1/index.html");
                            
                            ssize_t wr = send(client->getFd(), response.c_str(), response.size(), 0);
                            close(client->getFd());
                            if(FD_ISSET(client->getFd(), &s_wr))
                            {
                                FD_CLR(client->getFd(), &s_wr);
                                if (client->getFd() == max)
                                    max = max - 1;
                            }
                            server->removeClient(client->getFd());
                            response.clear();
                        }
                    }
                }
            }
        }















           fd_set s_rd;
        fd_set s_wr;
        fd_set s_ex;
        while (mgn.getmax() > 0)
        {
            FD_ZERO(&s_rd);
            FD_ZERO(&s_wr);
            s_rd = mgn.r_set();
            s_wr = mgn.w_set();
            int i_o = select(mgn.getmax()+1, &s_rd, &s_wr, NULL, NULL);
            if (i_o > 0)
            {
                for(int i = 0; i < FD_SETSIZE; i++)
                {
                    if (FD_ISSET(i, &s_rd))
                    {
                        if (mgn.findServerBySocket(i) != -1)
                        {
                            HTTPServer *server = mgn.getServerBySocket(i);
                            sock_t newSocket = server->accept();
                            if (newSocket > 0)
                            {
                                Client client(newSocket);
                                server->push(newSocket, client);
                                mgn.set_r(newSocket);
                                if (newSocket > mgn.getmax())
                                    mgn.setmax(newSocket);                               
                            }
                        }
                        else
                        {
                            HTTPServer *server = mgn.getServerByClientSocket(i);
                            Client *client = server->getClient(i);
                            sock_t clfd = client->getFd();
                            client->appendRequest();
                            

                            std::string response = "HTTP/1.1 200 OK\r\n";
                            response += "\r\n";
                            response += file("www/server1/index.html");
                            
                            ssize_t wr = send(clfd, response.c_str(), response.size(), 0);
                            close(clfd);
                            mgn.rm_r(client->getFd());
                            server->removeClient(clfd);
                        }
                    }
                }
            }
        }




if (!realPath.empty() && !possibleRoot.empty())
{
    if (isExist(actualPath))
    {
        if (isFile(actualPath))
        {
            if ((use = actualPath.find_last_of(".")) != std::string::npos)
                extension = actualPath.substr(use+1);
            std::cout << "IS FILE" << std::endl;
            std::cout << "Extension: " << extension << std::endl;
        }
        else if (isDir(actualPath))
            std::cout << "IS DIRECTORY" << std::endl;
    }
    else
    {
        std::cout << "NOT EXIST PATH" << std::endl;
    }
}
std::cout << "******************" << std::endl;